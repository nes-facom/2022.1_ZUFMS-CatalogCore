/* tslint:disable */
/* eslint-disable */
/**
 * Coleção Zoológica Online ZUFMS
 * Coleção Zoológica – Incremento e movimentação do acervo  ## Visão geral 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: suporte.agetic@ufms.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessTokenResponse
 */
export interface AccessTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'refresh_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessTokenResponse
     */
    'token_type'?: AccessTokenResponseTokenTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof AccessTokenResponse
     */
    'expires_in'?: number;
}

export const AccessTokenResponseTokenTypeEnum = {
    Bearer: 'bearer'
} as const;

export type AccessTokenResponseTokenTypeEnum = typeof AccessTokenResponseTokenTypeEnum[keyof typeof AccessTokenResponseTokenTypeEnum];

/**
 * @type AuthRequest
 * @export
 */
export type AuthRequest = ClientCredentialsAuthRequest | UserOtpAuthRequest;

/**
 * 
 * @export
 * @interface AuthenticationError
 */
export interface AuthenticationError {
    /**
     * 
     * @type {number}
     * @memberof AuthenticationError
     */
    'code'?: number // AuthenticationErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationError
     */
    'title'?: string // AuthenticationErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthenticationError
     */
    'description'?: string // AuthenticationErrorDescriptionEnum;
}
/**
 * 
 * @export
 * @interface AuthenticationErrorResponse
 */
export interface AuthenticationErrorResponse {
    /**
     * 
     * @type {Array<AuthenticationError>}
     * @memberof AuthenticationErrorResponse
     */
    'errors'?: Array<AuthenticationError>;
}
/**
 * 
 * @export
 * @interface ClientCredentialsAuthRequest
 */
export interface ClientCredentialsAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof ClientCredentialsAuthRequest
     */
    'type'?: ClientCredentialsAuthRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ClientCredentialsAuthRequest
     */
    'client_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientCredentialsAuthRequest
     */
    'client_secret'?: string;
    /**
     * String de escopos separados por espaços  #### Escopos válidos  ##### Client  - `internal.client`: Permissão de um client interno do sistema, podendo autenticar usuários utilizando de e-mail + password (método `auth.token` com `\"type\": \"password\"`) - `client.auth:otp`: Permite autenticar um usuário utilizando OTP (one-time password)  ##### User  - `admin`: Permissão de um usuário adminstrativo. Permite leitura e escrita de todas as entidades - `occurrences`: Permite leitura e escrita de ocorrências - `occurrences:read`: Permite leitura de ocorrências - `users`: Permite leitura e escrita de usuários - `users:read`: Permite leitura de outros usuários 
     * @type {string}
     * @memberof ClientCredentialsAuthRequest
     */
    'scope'?: string;
}

export const ClientCredentialsAuthRequestTypeEnum = {
    ClientCredentials: 'client_credentials'
} as const;

export type ClientCredentialsAuthRequestTypeEnum = typeof ClientCredentialsAuthRequestTypeEnum[keyof typeof ClientCredentialsAuthRequestTypeEnum];

/**
 * 
 * @export
 * @interface CreateUserRequest
 */
export interface CreateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof CreateUserRequest
     */
    'allowed_scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface DataNotFoundError
 */
export interface DataNotFoundError {
    /**
     * 
     * @type {number}
     * @memberof DataNotFoundError
     */
    'code'?: number // DataNotFoundErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof DataNotFoundError
     */
    'title'?: string // DataNotFoundErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof DataNotFoundError
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface DataNotFoundErrorResponse
 */
export interface DataNotFoundErrorResponse {
    /**
     * 
     * @type {Array<DataNotFoundError>}
     * @memberof DataNotFoundErrorResponse
     */
    'errors'?: Array<DataNotFoundError>;
}
/**
 * 
 * @export
 * @interface DataValidationError
 */
export interface DataValidationError {
    /**
     * 
     * @type {number}
     * @memberof DataValidationError
     */
    'code'?: number // DataValidationErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof DataValidationError
     */
    'title'?: string // DataValidationErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof DataValidationError
     */
    'description'?: string;
    /**
     * 
     * @type {number}
     * @memberof DataValidationError
     */
    '_index'?: number;
    /**
     * 
     * @type {string}
     * @memberof DataValidationError
     */
    '_term'?: string;
}
/**
 * 
 * @export
 * @interface DataValidationErrorResponse
 */
export interface DataValidationErrorResponse {
    /**
     * 
     * @type {Array<DataValidationError>}
     * @memberof DataValidationErrorResponse
     */
    'errors'?: Array<DataValidationError>;
}
/**
 * 
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     * 
     * @type {Array<Error>}
     * @memberof ErrorResponse
     */
    'errors'?: Array<Error>;
}
/**
 * 
 * @export
 * @interface FileReadError
 */
export interface FileReadError {
    /**
     * 
     * @type {number}
     * @memberof FileReadError
     */
    'code'?: number // FileReadErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof FileReadError
     */
    'title'?: string // FileReadErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof FileReadError
     */
    'description'?: string // FileReadErrorDescriptionEnum;
}
/**
 * 
 * @export
 * @interface FileReadErrorResponse
 */
export interface FileReadErrorResponse {
    /**
     * 
     * @type {Array<FileReadError>}
     * @memberof FileReadErrorResponse
     */
    'errors'?: Array<FileReadError>;
}
/**
 * 
 * @export
 * @interface InsufficientPermissionsError
 */
export interface InsufficientPermissionsError {
    /**
     * 
     * @type {number}
     * @memberof InsufficientPermissionsError
     */
    'code'?: number // InsufficientPermissionsErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof InsufficientPermissionsError
     */
    'title'?: string // InsufficientPermissionsErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof InsufficientPermissionsError
     */
    'description'?: string //  InsufficientPermissionsErrorDescriptionEnum;
}
/**
 * 
 * @export
 * @interface InsufficientPermissionsErrorResponse
 */
export interface InsufficientPermissionsErrorResponse {
    /**
     * 
     * @type {Array<InsufficientPermissionsError>}
     * @memberof InsufficientPermissionsErrorResponse
     */
    'errors'?: Array<InsufficientPermissionsError>;
}
/**
 * 
 * @export
 * @interface InternalError
 */
export interface InternalError {
    /**
     * 
     * @type {number}
     * @memberof InternalError
     */
    'code'?: number // InternalErrorCodeEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalError
     */
    'title'?: string // InternalErrorTitleEnum;
    /**
     * 
     * @type {string}
     * @memberof InternalError
     */
    'description'?: string // InternalErrorDescriptionEnum;
}
/**
 * 
 * @export
 * @interface InternalErrorResponse
 */
export interface InternalErrorResponse {
    /**
     * 
     * @type {Array<InternalError>}
     * @memberof InternalErrorResponse
     */
    'errors'?: Array<InternalError>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * 
     * @type {number}
     * @memberof ModelError
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelError
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface OtpRequest
 */
export interface OtpRequest {
    /**
     * 
     * @type {string}
     * @memberof OtpRequest
     */
    'otp_method'?: OtpRequestOtpMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof OtpRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof OtpRequest
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof OtpRequest
     */
    'state'?: string;
}

export const OtpRequestOtpMethodEnum = {
    Email: 'email'
} as const;

export type OtpRequestOtpMethodEnum = typeof OtpRequestOtpMethodEnum[keyof typeof OtpRequestOtpMethodEnum];

/**
 * 
 * @export
 * @interface OtpResponse
 */
export interface OtpResponse {
    /**
     * 
     * @type {string}
     * @memberof OtpResponse
     */
    'message'?: OtpResponseMessageEnum;
}

export const OtpResponseMessageEnum = {
    OtpEnviado: 'OTP enviado'
} as const;

export type OtpResponseMessageEnum = typeof OtpResponseMessageEnum[keyof typeof OtpResponseMessageEnum];

/**
 * 
 * @export
 * @interface RevokeAccessTokenRequest
 */
export interface RevokeAccessTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RevokeAccessTokenRequest
     */
    'token'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserRequest
     */
    'allowed_scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof User
     */
    'allowed_scopes'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UserOtpAuthRequest
 */
export interface UserOtpAuthRequest {
    /**
     * 
     * @type {string}
     * @memberof UserOtpAuthRequest
     */
    'type'?: UserOtpAuthRequestTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserOtpAuthRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserOtpAuthRequest
     */
    'otp_method'?: UserOtpAuthRequestOtpMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof UserOtpAuthRequest
     */
    'otp'?: string;
    /**
     * String de escopos separados por espaços  #### Escopos válidos  ##### Client  - `internal.client`: Permissão de um client interno do sistema, podendo autenticar usuários utilizando de e-mail + password (método `auth.token` com `\"type\": \"password\"`) - `client.auth:otp`: Permite autenticar um usuário utilizando OTP (one-time password)  ##### User  - `admin`: Permissão de um usuário adminstrativo. Permite leitura e escrita de todas as entidades - `occurrences`: Permite leitura e escrita de ocorrências - `occurrences:read`: Permite leitura de ocorrências - `users`: Permite leitura e escrita de usuários - `users:read`: Permite leitura de outros usuários 
     * @type {string}
     * @memberof UserOtpAuthRequest
     */
    'scope'?: string;
}

export const UserOtpAuthRequestTypeEnum = {
    Otp: 'otp'
} as const;

export type UserOtpAuthRequestTypeEnum = typeof UserOtpAuthRequestTypeEnum[keyof typeof UserOtpAuthRequestTypeEnum];
export const UserOtpAuthRequestOtpMethodEnum = {
    Email: 'email'
} as const;

export type UserOtpAuthRequestOtpMethodEnum = typeof UserOtpAuthRequestOtpMethodEnum[keyof typeof UserOtpAuthRequestOtpMethodEnum];

/**
 * 
 * @export
 * @interface ZUFMSCore
 */
export interface ZUFMSCore {
    /**
     * Grupo ao qual o registro faz parte
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:section'?: string;
    /**
     * data que o registro foi criado ou alterado, no padrão AAAA-MM-DD
     * @type {string}
     * @memberof ZUFMSCore
     */
    'dcterms:modified'?: string;
    /**
     * informação que falta em uma das colunas e deve ser procurada
     * @type {string}
     * @memberof ZUFMSCore
     */
    'informationWithheld'?: string;
    /**
     * PreservedSpecimen: um recurso que descreve um espécime preservado. LivingSpecimen: um recurso que descreve um espécime vivo. HumanObservation: um recurso que descreve uma observação feita por uma ou mais pessoas. MachineObservation: um recurso que descreve uma observação feita por máquina. Sample: um recurso que descreve os resultados físicos de uma amostragem.
     * @type {string}
     * @memberof ZUFMSCore
     */
    'basisOfRecord'?: string;
    /**
     * sigla da instituição
     * @type {string}
     * @memberof ZUFMSCore
     */
    'institutionCode'?: string;
    /**
     * sigla da coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    'collectionCode'?: string;
    /**
     * citação do artigo em que este exemplar foi utilizado, concatenar com \";\"
     * @type {string}
     * @memberof ZUFMSCore
     */
    'dcterms:bibliographicCitation'?: string;
    /**
     * o título do projeto no qual houve envolvimento de coletas
     * @type {string}
     * @memberof ZUFMSCore
     */
    'datasetName'?: string;
    /**
     * local numerado onde o exemplar está armazenado (utilize ALT+0150 para inserir a \"meia-risca\" se forem várias prateleiras)
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:shelfLocation'?: string;
    /**
     * acronímia da seção (ex.: AMP) que agrupa alfabeticamente vários tombos, desde que sejam mesmo táxon, local e ano de coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:flaskLocation'?: string;
    /**
     * exemplar não disponível
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:shippingGuide'?: string;
    /**
     * número de tombo do exemplar
     * @type {string}
     * @memberof ZUFMSCore
     */
    'catalogNumber'?: string;
    /**
     * quando proveniente de outra coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    'otherCatalogNumbers'?: string;
    /**
     * nome do coletor abreviado seguindo o exemplo \"SOBRENOME, N.\"
     * @type {string}
     * @memberof ZUFMSCore
     */
    'recordedBy'?: string;
    /**
     * número da etiqueta de campo, associada ao coletor
     * @type {string}
     * @memberof ZUFMSCore
     */
    'recordNumber'?: string;
    /**
     * tipo de preparação concatenado com \";\"
     * @type {string}
     * @memberof ZUFMSCore
     */
    'preparations'?: string;
    /**
     * se for em lote, informar a quantidade
     * @type {string}
     * @memberof ZUFMSCore
     */
    'individualCount'?: string;
    /**
     * Campo informado com vocabulário
     * @type {string}
     * @memberof ZUFMSCore
     */
    'sex'?: string;
    /**
     * o estágio de vida do especime no momento do registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    'lifeStage'?: string;
    /**
     * informa que fase reprodutiva se encontra
     * @type {string}
     * @memberof ZUFMSCore
     */
    'reproductiveCondition'?: string;
    /**
     * informa a real origem com vocabulário
     * @type {string}
     * @memberof ZUFMSCore
     */
    'establishmentMeans'?: string;
    /**
     * a ação que o espécime realizava quando ainda vivo
     * @type {string}
     * @memberof ZUFMSCore
     */
    'behavior'?: string;
    /**
     * observação ou comentário do espécime na hora da coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    'occurrenceRemarks'?: string;
    /**
     * informação do registro na coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    'disposition'?: string;
    /**
     * bibliografia relacionada ou direta
     * @type {string}
     * @memberof ZUFMSCore
     */
    'associatedReferences'?: string;
    /**
     * o link ou pasta onde está a mídia associada
     * @type {string}
     * @memberof ZUFMSCore
     */
    'associatedMedia'?: string;
    /**
     * identidade do exemplar, utilizado para evitar duplicações
     * @type {string}
     * @memberof ZUFMSCore
     */
    'occurrenceID'?: string;
    /**
     * espécime tombado que tenha relação com o registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    'associatedOccurrences'?: string;
    /**
     * identificações anteriores, informando táxon, determinador, data e método utilizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'previousIdentifications'?: string;
    /**
     * 
     * @type {string}
     * @memberof ZUFMSCore
     */
    'fieldNumber'?: string;
    /**
     * dia em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    'day'?: number;
    /**
     * mês em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    'month'?: number;
    /**
     * ano em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    'year'?: number;
    /**
     * hora única (hh:mm) ou intervalo (hh:mm/hh:mm)
     * @type {string}
     * @memberof ZUFMSCore
     */
    'eventTime'?: string;
    /**
     * data (aaaa-mm-dd) ou intervalo (aaaa-mm-dd/aaaa-mm-dd), mas se não houver todas informações informar apenas mês (aaaa-mm) ou ano (aaaa)
     * @type {string}
     * @memberof ZUFMSCore
     */
    'eventDate'?: string;
    /**
     * data clássica com mês em formato romano
     * @type {string}
     * @memberof ZUFMSCore
     */
    'verbatimEventDate'?: string;
    /**
     * descrição sucinta do método de coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    'samplingProtocol'?: string;
    /**
     * pode ser bioma, ecorregião que caracterize o ambiente natural do espécime
     * @type {string}
     * @memberof ZUFMSCore
     */
    'habitat'?: string;
    /**
     * comentários sobre o evento
     * @type {string}
     * @memberof ZUFMSCore
     */
    'eventRemarks'?: string;
    /**
     * pode ser um indicador da existencia de, b) uma referência a (publicação, link), ou c) texto das notas tomadas no campo sobre o evento
     * @type {string}
     * @memberof ZUFMSCore
     */
    'fieldNotes'?: string;
    /**
     * comentários ou notas que acompanham medições ou fatos; medidas concatenadas com \";\" informando unidade
     * @type {string}
     * @memberof ZUFMSCore
     */
    'measurementRemarks'?: string;
    /**
     * apenas se for um divisão válida
     * @type {string}
     * @memberof ZUFMSCore
     */
    'continent'?: string;
    /**
     * nome do país
     * @type {string}
     * @memberof ZUFMSCore
     */
    'country'?: string;
    /**
     * codificação de acordo com ISO3166-1 e código alfa-3
     * @type {string}
     * @memberof ZUFMSCore
     */
    'countryCode'?: string;
    /**
     * utilizar quando se trata de organismos aquáticos
     * @type {string}
     * @memberof ZUFMSCore
     */
    'verbatimLocality'?: string;
    /**
     * escrito por extenso, utilizar região quando são áreas de divisa entre estados
     * @type {string}
     * @memberof ZUFMSCore
     */
    'stateProvince'?: string;
    /**
     * o nome do município válido
     * @type {string}
     * @memberof ZUFMSCore
     */
    'county'?: string;
    /**
     * quando há necessidade de informar distrito ou sub-região (ex.: Pantanal da Nhecolândia)
     * @type {string}
     * @memberof ZUFMSCore
     */
    'municipality'?: string;
    /**
     * a localidade abaixo de município ou distrito
     * @type {string}
     * @memberof ZUFMSCore
     */
    'locality'?: string;
    /**
     * coordenada em formato decimal, a célula deve estar formatada em texto
     * @type {number}
     * @memberof ZUFMSCore
     */
    'decimalLatitude'?: number;
    /**
     * coordenada em formato decimal, a célula deve estar formatada em texto
     * @type {number}
     * @memberof ZUFMSCore
     */
    'decimalLongitude'?: number;
    /**
     * informar se não houver decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    'verbatimLatitude'?: string;
    /**
     * informar se não houver decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    'verbatimLongitude'?: string;
    /**
     * precisão em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    'coordinatePrecision'?: number;
    /**
     * informar somente se decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    'geodeticDatum'?: string;
    /**
     * quando não se sabe a coordenada exata; acesse http://boundingbox.klokantech.com/ para estimar o quadrante
     * @type {string}
     * @memberof ZUFMSCore
     */
    'footprintWKT'?: string;
    /**
     * limite inferior do intervalo da elevação
     * @type {number}
     * @memberof ZUFMSCore
     */
    'minimumElevationInMeters'?: number;
    /**
     * limite superior do intervalo da elevação
     * @type {number}
     * @memberof ZUFMSCore
     */
    'maximumElevationInMeters'?: number;
    /**
     * o nome do corpo d\'água lótico/lêntico onde foi coletado; mais detalhes acesse http://www.getty.edu/research/tools/vocabularies/tgn/
     * @type {string}
     * @memberof ZUFMSCore
     */
    'waterBody'?: string;
    /**
     * a menor profundidade de um intervalo de profundidades abaixo da superfície do local, em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    'minimumDepthInMeters'?: number;
    /**
     * a maior profundidade de um intervalo de profundidades abaixo da superfície do local, em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    'maximumDepthInMeters'?: number;
    /**
     * comentários sobre o local onde foi coletado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'locationRemarks'?: string;
    /**
     * quando não se sabe ao certo a identificação 
     * @type {string}
     * @memberof ZUFMSCore
     */
    'identificationQualifier'?: string;
    /**
     * o sobrenome e nome abreviado em caixa alta segundo o exemplo de quem identificou o material
     * @type {string}
     * @memberof ZUFMSCore
     */
    'identifiedBy'?: string;
    /**
     * data da determsinação no formato aaaa-mm-dd
     * @type {string}
     * @memberof ZUFMSCore
     */
    'dateIdentified'?: string;
    /**
     * informa se é tipo nomenclatural ou apenas voucher, se necessário concatenar com \";\"
     * @type {string}
     * @memberof ZUFMSCore
     */
    'typeStatus'?: string;
    /**
     * similar ao Nome Científico Aceito, mas aqui utilizamos sem autoria
     * @type {string}
     * @memberof ZUFMSCore
     */
    'scientificName'?: string;
    /**
     * autor e ano, segundo o código de nomenclatura seguido
     * @type {string}
     * @memberof ZUFMSCore
     */
    'scientificNameAuthorship'?: string;
    /**
     * identificação do táxon com autor até onde foi possível, não importando a categoria taxonômica
     * @type {string}
     * @memberof ZUFMSCore
     */
    'acceptedNameUsage'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'subgenus'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'genus'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:subtribe'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:tribe'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:subfamily'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'family'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:superfamily'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:infraorder'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:suborder'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'order'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:superorder'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:subclass'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'class'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'artificial:subphylum'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'phylum'?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    'kingdom'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'specificEpithet'?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'infraspecificEpithet'?: string;
    /**
     * informa até que nível taxonômico foi identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'taxonRank'?: string;
    /**
     * informa a condição taxonômica:
     * @type {string}
     * @memberof ZUFMSCore
     */
    'taxonomicStatus'?: string;
    /**
     * se for um táxon com problemas, informar o original
     * @type {string}
     * @memberof ZUFMSCore
     */
    'originalNameUsage'?: string;
    /**
     * nome popular hifenizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'vernacularName'?: string;
    /**
     * informa qual código ou sistema de classificação está sendo utilizado para o registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    'nomenclaturalCode'?: string;
    /**
     * o sistema de classificação no qual este grupo está organizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    'nameAccordingTo'?: string;
    /**
     * informar a relação com o Item Relacionado ao Catálogo
     * @type {string}
     * @memberof ZUFMSCore
     */
    'relationshipOfResource'?: string;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Solicitar um código de autenticação de um usuário
         * @param {OtpRequest} [otpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtp: async (otpRequest?: OtpRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/otp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(otpRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Revogar um token de acesso
         * @param {RevokeAccessTokenRequest} [revokeAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRevoke: async (revokeAccessTokenRequest?: RevokeAccessTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/revoke`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(revokeAccessTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ## Fluxo de autenticação do usuário através do front-end 1. Front-end se autentifica   - `FRONTEND_CLIENT_ID`, `FRONTEND_CLIENT_SECRET`: Credenciais do front-end  ``` POST https://zufms_api/auth/token Content-Type: application/json {   \"type\": \"client_credentials\",   \"client_id\": \"FRONTEND_CLIENT_ID\",   \"client_secret\": \"FRONTEND_CLIENT_SECRET\",   \"scope\": \"client.auth:otp\" } ```  2. Front-end solicita que um usuário receba um OTP   - `STATE`: String aleatória que deve ser salva em algum storage junto com o e-mail do usuário   - `USER_EMAIL`: E-mail do usuário ``` POST https://zufms_api/auth/otp Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"otp_method\": \"email\",   \"email\": \"USER_EMAIL\",   \"state\": \"STATE\" } ```  3. Usuário recebe um OTP e um link no e-mail  4.1. Caso clique no link  4.1.1. O usuário é redirecionado para https://zufms_web/auth/cb?otp=`OTP`&state=`STATE`   - O link de callback é obtido através do cadastro do client   - `OTP`: Código OTP   - `STATE`: State fornecido no passo `2.`  4.1.2. O front-end recupera o e-mail do storage usando o `STATE` recebido  4.1.3. O front-end realiza a autenticação do usuário   - `SCOPE`: Escopo de autorização solicitado pelo usuário (ver `AccessTokenScope`)  ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  4.2. Caso o usuário digite o código no front-end  4.2.1. O front-end realiza a autenticação do usuário ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  5. O front-end está apto a utilizar a conta do usuário (access_token) em suas requisições 
         * @summary Realizar autenticação
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken: async (authRequest?: AuthRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Solicitar um código de autenticação de um usuário
         * @param {OtpRequest} [otpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOtp(otpRequest?: OtpRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OtpResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOtp(otpRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Revogar um token de acesso
         * @param {RevokeAccessTokenRequest} [revokeAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRevoke(revokeAccessTokenRequest?: RevokeAccessTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRevoke(revokeAccessTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * ## Fluxo de autenticação do usuário através do front-end 1. Front-end se autentifica   - `FRONTEND_CLIENT_ID`, `FRONTEND_CLIENT_SECRET`: Credenciais do front-end  ``` POST https://zufms_api/auth/token Content-Type: application/json {   \"type\": \"client_credentials\",   \"client_id\": \"FRONTEND_CLIENT_ID\",   \"client_secret\": \"FRONTEND_CLIENT_SECRET\",   \"scope\": \"client.auth:otp\" } ```  2. Front-end solicita que um usuário receba um OTP   - `STATE`: String aleatória que deve ser salva em algum storage junto com o e-mail do usuário   - `USER_EMAIL`: E-mail do usuário ``` POST https://zufms_api/auth/otp Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"otp_method\": \"email\",   \"email\": \"USER_EMAIL\",   \"state\": \"STATE\" } ```  3. Usuário recebe um OTP e um link no e-mail  4.1. Caso clique no link  4.1.1. O usuário é redirecionado para https://zufms_web/auth/cb?otp=`OTP`&state=`STATE`   - O link de callback é obtido através do cadastro do client   - `OTP`: Código OTP   - `STATE`: State fornecido no passo `2.`  4.1.2. O front-end recupera o e-mail do storage usando o `STATE` recebido  4.1.3. O front-end realiza a autenticação do usuário   - `SCOPE`: Escopo de autorização solicitado pelo usuário (ver `AccessTokenScope`)  ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  4.2. Caso o usuário digite o código no front-end  4.2.1. O front-end realiza a autenticação do usuário ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  5. O front-end está apto a utilizar a conta do usuário (access_token) em suas requisições 
         * @summary Realizar autenticação
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authToken(authRequest?: AuthRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authToken(authRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Solicitar um código de autenticação de um usuário
         * @param {OtpRequest} [otpRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOtp(otpRequest?: OtpRequest, options?: any): AxiosPromise<OtpResponse> {
            return localVarFp.authOtp(otpRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `client.auth:otp` ou maior
         * @summary Revogar um token de acesso
         * @param {RevokeAccessTokenRequest} [revokeAccessTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRevoke(revokeAccessTokenRequest?: RevokeAccessTokenRequest, options?: any): AxiosPromise<void> {
            return localVarFp.authRevoke(revokeAccessTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * ## Fluxo de autenticação do usuário através do front-end 1. Front-end se autentifica   - `FRONTEND_CLIENT_ID`, `FRONTEND_CLIENT_SECRET`: Credenciais do front-end  ``` POST https://zufms_api/auth/token Content-Type: application/json {   \"type\": \"client_credentials\",   \"client_id\": \"FRONTEND_CLIENT_ID\",   \"client_secret\": \"FRONTEND_CLIENT_SECRET\",   \"scope\": \"client.auth:otp\" } ```  2. Front-end solicita que um usuário receba um OTP   - `STATE`: String aleatória que deve ser salva em algum storage junto com o e-mail do usuário   - `USER_EMAIL`: E-mail do usuário ``` POST https://zufms_api/auth/otp Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"otp_method\": \"email\",   \"email\": \"USER_EMAIL\",   \"state\": \"STATE\" } ```  3. Usuário recebe um OTP e um link no e-mail  4.1. Caso clique no link  4.1.1. O usuário é redirecionado para https://zufms_web/auth/cb?otp=`OTP`&state=`STATE`   - O link de callback é obtido através do cadastro do client   - `OTP`: Código OTP   - `STATE`: State fornecido no passo `2.`  4.1.2. O front-end recupera o e-mail do storage usando o `STATE` recebido  4.1.3. O front-end realiza a autenticação do usuário   - `SCOPE`: Escopo de autorização solicitado pelo usuário (ver `AccessTokenScope`)  ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  4.2. Caso o usuário digite o código no front-end  4.2.1. O front-end realiza a autenticação do usuário ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  5. O front-end está apto a utilizar a conta do usuário (access_token) em suas requisições 
         * @summary Realizar autenticação
         * @param {AuthRequest} [authRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authToken(authRequest?: AuthRequest, options?: any): AxiosPromise<AccessTokenResponse> {
            return localVarFp.authToken(authRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Necessita de permissão `client.auth:otp` ou maior
     * @summary Solicitar um código de autenticação de um usuário
     * @param {OtpRequest} [otpRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOtp(otpRequest?: OtpRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOtp(otpRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `client.auth:otp` ou maior
     * @summary Revogar um token de acesso
     * @param {RevokeAccessTokenRequest} [revokeAccessTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRevoke(revokeAccessTokenRequest?: RevokeAccessTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRevoke(revokeAccessTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ## Fluxo de autenticação do usuário através do front-end 1. Front-end se autentifica   - `FRONTEND_CLIENT_ID`, `FRONTEND_CLIENT_SECRET`: Credenciais do front-end  ``` POST https://zufms_api/auth/token Content-Type: application/json {   \"type\": \"client_credentials\",   \"client_id\": \"FRONTEND_CLIENT_ID\",   \"client_secret\": \"FRONTEND_CLIENT_SECRET\",   \"scope\": \"client.auth:otp\" } ```  2. Front-end solicita que um usuário receba um OTP   - `STATE`: String aleatória que deve ser salva em algum storage junto com o e-mail do usuário   - `USER_EMAIL`: E-mail do usuário ``` POST https://zufms_api/auth/otp Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"otp_method\": \"email\",   \"email\": \"USER_EMAIL\",   \"state\": \"STATE\" } ```  3. Usuário recebe um OTP e um link no e-mail  4.1. Caso clique no link  4.1.1. O usuário é redirecionado para https://zufms_web/auth/cb?otp=`OTP`&state=`STATE`   - O link de callback é obtido através do cadastro do client   - `OTP`: Código OTP   - `STATE`: State fornecido no passo `2.`  4.1.2. O front-end recupera o e-mail do storage usando o `STATE` recebido  4.1.3. O front-end realiza a autenticação do usuário   - `SCOPE`: Escopo de autorização solicitado pelo usuário (ver `AccessTokenScope`)  ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  4.2. Caso o usuário digite o código no front-end  4.2.1. O front-end realiza a autenticação do usuário ``` POST https://zufms_api/auth/token Content-Type: application/json Authorization: Bearer FRONTEND_ACCESS_TOKEN {   \"type\": \"otp\",   \"otp_method\": \"email\",   \"otp\": \"OTP\",   \"email\": \"USER_EMAIL\",   \"scope\": \"SCOPE\" } ```  5. O front-end está apto a utilizar a conta do usuário (access_token) em suas requisições 
     * @summary Realizar autenticação
     * @param {AuthRequest} [authRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authToken(authRequest?: AuthRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authToken(authRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OccurrencesApi - axios parameter creator
 * @export
 */
export const OccurrencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Necessita de permissão `occurrences:read` ou maior 
         * @summary Realiza a busca dos dados de autocomplete de um termo específico
         * @param {string} term Termo a ser pesquisado
         * @param {string} value Valor do termo
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesAutocomplete: async (term: string, value: string, start?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'term' is not null or undefined
            assertParamExists('occurrencesAutocomplete', 'term', term)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('occurrencesAutocomplete', 'value', value)
            const localVarPath = `/occurrences/autocomplete`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Adicionar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesCreateMany: async (zUFMSCore?: Array<ZUFMSCore>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(zUFMSCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir múltiplas entradas ao acervo
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDeleteMany: async (requestBody?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDeleteOne: async (occurrenceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'occurrenceID' is not null or undefined
            assertParamExists('occurrencesDeleteOne', 'occurrenceID', occurrenceID)
            const localVarPath = `/occurrences/{occurrenceID}`
                .replace(`{${"occurrenceID"}}`, encodeURIComponent(String(occurrenceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences` ou maior 
         * @summary Realizar o upload, processamento e submissão dos dados de um arquivo de ocorrências ao acervo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesFile: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences/file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences:read` ou maior 
         * @summary Realizar o processamento de um arquivo de ocorrências
         * @param {any} [file] 
         * @param {string} [section] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesFileVerify: async (file?: any, section?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences/file/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
            if (section !== undefined) { 
                localVarFormParams.append('section', section as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar entradas do acervo
         * @param {string} [sortBy] Atributo de paginação  Define uma ordenação para o retorno dos dados 
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {string} [artificialsection] Filtra a busca pelo atributo &#x60;artificial:section&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesGetAll: async (sortBy?: string, start?: number, limit?: number, artificialsection?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (artificialsection !== undefined) {
                localVarQueryParameter['artificial:section'] = artificialsection;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesGetOne: async (occurrenceID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'occurrenceID' is not null or undefined
            assertParamExists('occurrencesGetOne', 'occurrenceID', occurrenceID)
            const localVarPath = `/occurrences/{occurrenceID}`
                .replace(`{${"occurrenceID"}}`, encodeURIComponent(String(occurrenceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdateMany: async (zUFMSCore?: Array<ZUFMSCore>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/occurrences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(zUFMSCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {ZUFMSCore} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdateOne: async (occurrenceID: string, zUFMSCore?: ZUFMSCore, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'occurrenceID' is not null or undefined
            assertParamExists('occurrencesUpdateOne', 'occurrenceID', occurrenceID)
            const localVarPath = `/occurrences/{occurrenceID}`
                .replace(`{${"occurrenceID"}}`, encodeURIComponent(String(occurrenceID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(zUFMSCore, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OccurrencesApi - functional programming interface
 * @export
 */
export const OccurrencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OccurrencesApiAxiosParamCreator(configuration)
    return {
        /**
         * Necessita de permissão `occurrences:read` ou maior 
         * @summary Realiza a busca dos dados de autocomplete de um termo específico
         * @param {string} term Termo a ser pesquisado
         * @param {string} value Valor do termo
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesAutocomplete(term: string, value: string, start?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesAutocomplete(term, value, start, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Adicionar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesCreateMany(zUFMSCore?: Array<ZUFMSCore>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesCreateMany(zUFMSCore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir múltiplas entradas ao acervo
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesDeleteMany(requestBody?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesDeleteMany(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesDeleteOne(occurrenceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZUFMSCore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesDeleteOne(occurrenceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences` ou maior 
         * @summary Realizar o upload, processamento e submissão dos dados de um arquivo de ocorrências ao acervo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesFile(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesFile(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences:read` ou maior 
         * @summary Realizar o processamento de um arquivo de ocorrências
         * @param {any} [file] 
         * @param {string} [section] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesFileVerify(file?: any, section?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesFileVerify(file, section, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar entradas do acervo
         * @param {string} [sortBy] Atributo de paginação  Define uma ordenação para o retorno dos dados 
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {string} [artificialsection] Filtra a busca pelo atributo &#x60;artificial:section&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesGetAll(sortBy?: string, start?: number, limit?: number, artificialsection?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesGetAll(sortBy, start, limit, artificialsection, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesGetOne(occurrenceID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesGetOne(occurrenceID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesUpdateMany(zUFMSCore?: Array<ZUFMSCore>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ZUFMSCore>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesUpdateMany(zUFMSCore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {ZUFMSCore} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async occurrencesUpdateOne(occurrenceID: string, zUFMSCore?: ZUFMSCore, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZUFMSCore>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.occurrencesUpdateOne(occurrenceID, zUFMSCore, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OccurrencesApi - factory interface
 * @export
 */
export const OccurrencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OccurrencesApiFp(configuration)
    return {
        /**
         * Necessita de permissão `occurrences:read` ou maior 
         * @summary Realiza a busca dos dados de autocomplete de um termo específico
         * @param {string} term Termo a ser pesquisado
         * @param {string} value Valor do termo
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesAutocomplete(term: string, value: string, start?: number, limit?: number, options?: any): AxiosPromise<Array<string>> {
            return localVarFp.occurrencesAutocomplete(term, value, start, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Adicionar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesCreateMany(zUFMSCore?: Array<ZUFMSCore>, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesCreateMany(zUFMSCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir múltiplas entradas ao acervo
         * @param {Array<string>} [requestBody] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDeleteMany(requestBody?: Array<string>, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesDeleteMany(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Excluir uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesDeleteOne(occurrenceID: string, options?: any): AxiosPromise<ZUFMSCore> {
            return localVarFp.occurrencesDeleteOne(occurrenceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences` ou maior 
         * @summary Realizar o upload, processamento e submissão dos dados de um arquivo de ocorrências ao acervo
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesFile(options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesFile(options).then((request) => request(axios, basePath));
        },
        /**
         * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences:read` ou maior 
         * @summary Realizar o processamento de um arquivo de ocorrências
         * @param {any} [file] 
         * @param {string} [section] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesFileVerify(file?: any, section?: string, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesFileVerify(file, section, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar entradas do acervo
         * @param {string} [sortBy] Atributo de paginação  Define uma ordenação para o retorno dos dados 
         * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
         * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
         * @param {string} [artificialsection] Filtra a busca pelo atributo &#x60;artificial:section&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesGetAll(sortBy?: string, start?: number, limit?: number, artificialsection?: string, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesGetAll(sortBy, start, limit, artificialsection, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences:read` ou maior
         * @summary Buscar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesGetOne(occurrenceID: string, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesGetOne(occurrenceID, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar múltiplas entradas ao acervo
         * @param {Array<ZUFMSCore>} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdateMany(zUFMSCore?: Array<ZUFMSCore>, options?: any): AxiosPromise<Array<ZUFMSCore>> {
            return localVarFp.occurrencesUpdateMany(zUFMSCore, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `occurrences` ou maior
         * @summary Editar uma entrada do acervo
         * @param {string} occurrenceID 
         * @param {ZUFMSCore} [zUFMSCore] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        occurrencesUpdateOne(occurrenceID: string, zUFMSCore?: ZUFMSCore, options?: any): AxiosPromise<ZUFMSCore> {
            return localVarFp.occurrencesUpdateOne(occurrenceID, zUFMSCore, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OccurrencesApi - object-oriented interface
 * @export
 * @class OccurrencesApi
 * @extends {BaseAPI}
 */
export class OccurrencesApi extends BaseAPI {
    /**
     * Necessita de permissão `occurrences:read` ou maior 
     * @summary Realiza a busca dos dados de autocomplete de um termo específico
     * @param {string} term Termo a ser pesquisado
     * @param {string} value Valor do termo
     * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
     * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesAutocomplete(term: string, value: string, start?: number, limit?: number, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesAutocomplete(term, value, start, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences` ou maior
     * @summary Adicionar múltiplas entradas ao acervo
     * @param {Array<ZUFMSCore>} [zUFMSCore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesCreateMany(zUFMSCore?: Array<ZUFMSCore>, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesCreateMany(zUFMSCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences` ou maior
     * @summary Excluir múltiplas entradas ao acervo
     * @param {Array<string>} [requestBody] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesDeleteMany(requestBody?: Array<string>, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesDeleteMany(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences` ou maior
     * @summary Excluir uma entrada do acervo
     * @param {string} occurrenceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesDeleteOne(occurrenceID: string, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesDeleteOne(occurrenceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences` ou maior 
     * @summary Realizar o upload, processamento e submissão dos dados de um arquivo de ocorrências ao acervo
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesFile(options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesFile(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Realizar o upload e processamento de uma ou mais entradas formatadas em xlsx ou csv  Necessita de permissão `occurrences:read` ou maior 
     * @summary Realizar o processamento de um arquivo de ocorrências
     * @param {any} [file] 
     * @param {string} [section] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesFileVerify(file?: any, section?: string, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesFileVerify(file, section, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences:read` ou maior
     * @summary Buscar entradas do acervo
     * @param {string} [sortBy] Atributo de paginação  Define uma ordenação para o retorno dos dados 
     * @param {number} [start] Atributo de paginação  Define o índice do primeiro dado a ser retornado 
     * @param {number} [limit] Atributo de paginação  Define o índice do último dado a ser retornado 
     * @param {string} [artificialsection] Filtra a busca pelo atributo &#x60;artificial:section&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesGetAll(sortBy?: string, start?: number, limit?: number, artificialsection?: string, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesGetAll(sortBy, start, limit, artificialsection, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences:read` ou maior
     * @summary Buscar uma entrada do acervo
     * @param {string} occurrenceID 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesGetOne(occurrenceID: string, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesGetOne(occurrenceID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences` ou maior
     * @summary Editar múltiplas entradas ao acervo
     * @param {Array<ZUFMSCore>} [zUFMSCore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesUpdateMany(zUFMSCore?: Array<ZUFMSCore>, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesUpdateMany(zUFMSCore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `occurrences` ou maior
     * @summary Editar uma entrada do acervo
     * @param {string} occurrenceID 
     * @param {ZUFMSCore} [zUFMSCore] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OccurrencesApi
     */
    public occurrencesUpdateOne(occurrenceID: string, zUFMSCore?: ZUFMSCore, options?: AxiosRequestConfig) {
        return OccurrencesApiFp(this.configuration).occurrencesUpdateOne(occurrenceID, zUFMSCore, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Necessita de permissão `users` ou maior
         * @summary Criar usuário
         * @param {CreateUserRequest} [createUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateOne: async (createUserRequest?: CreateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Excluir usuário
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDeleteOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuários
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetAll: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuário pelo id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetOne: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersGetOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Editar usuário
         * @param {string} id 
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateOne: async (id: string, updateUserRequest?: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUpdateOne', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access_token required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Necessita de permissão `users` ou maior
         * @summary Criar usuário
         * @param {CreateUserRequest} [createUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCreateOne(createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCreateOne(createUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Excluir usuário
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuários
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetAll(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetAll(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuário pelo id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGetOne(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGetOne(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Editar usuário
         * @param {string} id 
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUpdateOne(id: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUpdateOne(id, updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Necessita de permissão `users` ou maior
         * @summary Criar usuário
         * @param {CreateUserRequest} [createUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCreateOne(createUserRequest?: CreateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.usersCreateOne(createUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Excluir usuário
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteOne(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.usersDeleteOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuários
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetAll(options?: any): AxiosPromise<Array<User>> {
            return localVarFp.usersGetAll(options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
         * @summary Buscar usuário pelo id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGetOne(id: string, options?: any): AxiosPromise<User> {
            return localVarFp.usersGetOne(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Necessita de permissão `users` ou maior
         * @summary Editar usuário
         * @param {string} id 
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUpdateOne(id: string, updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.usersUpdateOne(id, updateUserRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Necessita de permissão `users` ou maior
     * @summary Criar usuário
     * @param {CreateUserRequest} [createUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCreateOne(createUserRequest?: CreateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCreateOne(createUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `users` ou maior
     * @summary Excluir usuário
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteOne(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeleteOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
     * @summary Buscar usuários
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetAll(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGetAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `users:read` ou maior para visualizar infomações básicas de outros usuários  Necessita de permissão `users` ou maior para visualizar todas as informações de outros usuários 
     * @summary Buscar usuário pelo id
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGetOne(id: string, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGetOne(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Necessita de permissão `users` ou maior
     * @summary Editar usuário
     * @param {string} id 
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUpdateOne(id: string, updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUpdateOne(id, updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


