/* tslint:disable */
/* eslint-disable */
/**
 * Coleção Zoológica Online ZUFMS
 * Coleção Zoológica – Incremento e movimentação do acervo  ## Visão geral 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: suporte.agetic@ufms.br
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface ZUFMSCore
 */
export interface ZUFMSCore {
    /**
     * Grupo ao qual o registro faz parte
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsection?: string;
    /**
     * data que o registro foi criado ou alterado, no padrão AAAA-MM-DD
     * @type {Date}
     * @memberof ZUFMSCore
     */
    dctermsmodified?: Date;
    /**
     * informação que falta em uma das colunas e deve ser procurada
     * @type {string}
     * @memberof ZUFMSCore
     */
    informationWithheld?: string;
    /**
     * PreservedSpecimen: um recurso que descreve um espécime preservado. LivingSpecimen: um recurso que descreve um espécime vivo. HumanObservation: um recurso que descreve uma observação feita por uma ou mais pessoas. MachineObservation: um recurso que descreve uma observação feita por máquina. Sample: um recurso que descreve os resultados físicos de uma amostragem.
     * @type {string}
     * @memberof ZUFMSCore
     */
    basisOfRecord?: string;
    /**
     * sigla da instituição
     * @type {string}
     * @memberof ZUFMSCore
     */
    institutionCode?: string;
    /**
     * sigla da coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    collectionCode?: string;
    /**
     * citação do artigo em que este exemplar foi utilizado, concatenar com ";"
     * @type {string}
     * @memberof ZUFMSCore
     */
    dctermsbibliographicCitation?: string;
    /**
     * o título do projeto no qual houve envolvimento de coletas
     * @type {string}
     * @memberof ZUFMSCore
     */
    datasetName?: string;
    /**
     * local numerado onde o exemplar está armazenado (utilize ALT+0150 para inserir a "meia-risca" se forem várias prateleiras)
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialshelfLocation?: string;
    /**
     * acronímia da seção (ex.: AMP) que agrupa alfabeticamente vários tombos, desde que sejam mesmo táxon, local e ano de coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialflaskLocation?: string;
    /**
     * exemplar não disponível
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialshippingGuide?: string;
    /**
     * número de tombo do exemplar
     * @type {string}
     * @memberof ZUFMSCore
     */
    catalogNumber?: string;
    /**
     * quando proveniente de outra coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    otherCatalogNumbers?: string;
    /**
     * nome do coletor abreviado seguindo o exemplo "SOBRENOME, N."
     * @type {string}
     * @memberof ZUFMSCore
     */
    recordedBy?: string;
    /**
     * número da etiqueta de campo, associada ao coletor
     * @type {string}
     * @memberof ZUFMSCore
     */
    recordNumber?: string;
    /**
     * tipo de preparação concatenado com ";"
     * @type {string}
     * @memberof ZUFMSCore
     */
    preparations?: string;
    /**
     * se for em lote, informar a quantidade
     * @type {string}
     * @memberof ZUFMSCore
     */
    individualCount?: string;
    /**
     * Campo informado com vocabulário
     * @type {string}
     * @memberof ZUFMSCore
     */
    sex?: string;
    /**
     * o estágio de vida do especime no momento do registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    lifeStage?: string;
    /**
     * informa que fase reprodutiva se encontra
     * @type {string}
     * @memberof ZUFMSCore
     */
    reproductiveCondition?: string;
    /**
     * informa a real origem com vocabulário
     * @type {string}
     * @memberof ZUFMSCore
     */
    establishmentMeans?: string;
    /**
     * a ação que o espécime realizava quando ainda vivo
     * @type {string}
     * @memberof ZUFMSCore
     */
    behavior?: string;
    /**
     * observação ou comentário do espécime na hora da coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    occurrenceRemarks?: string;
    /**
     * informação do registro na coleção
     * @type {string}
     * @memberof ZUFMSCore
     */
    disposition?: string;
    /**
     * bibliografia relacionada ou direta
     * @type {string}
     * @memberof ZUFMSCore
     */
    associatedReferences?: string;
    /**
     * o link ou pasta onde está a mídia associada
     * @type {string}
     * @memberof ZUFMSCore
     */
    associatedMedia?: string;
    /**
     * identidade do exemplar, utilizado para evitar duplicações
     * @type {string}
     * @memberof ZUFMSCore
     */
    occurrenceID?: string;
    /**
     * espécime tombado que tenha relação com o registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    associatedOccurrences?: string;
    /**
     * identificações anteriores, informando táxon, determinador, data e método utilizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    previousIdentifications?: string;
    /**
     * 
     * @type {string}
     * @memberof ZUFMSCore
     */
    fieldNumber?: string;
    /**
     * dia em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    day?: number;
    /**
     * mês em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    month?: number;
    /**
     * ano em algarismo arábico
     * @type {number}
     * @memberof ZUFMSCore
     */
    year?: number;
    /**
     * hora única (hh:mm) ou intervalo (hh:mm/hh:mm)
     * @type {string}
     * @memberof ZUFMSCore
     */
    eventTime?: string;
    /**
     * data (aaaa-mm-dd) ou intervalo (aaaa-mm-dd/aaaa-mm-dd), mas se não houver todas informações informar apenas mês (aaaa-mm) ou ano (aaaa)
     * @type {string}
     * @memberof ZUFMSCore
     */
    eventDate?: string;
    /**
     * data clássica com mês em formato romano
     * @type {string}
     * @memberof ZUFMSCore
     */
    verbatimEventDate?: string;
    /**
     * descrição sucinta do método de coleta
     * @type {string}
     * @memberof ZUFMSCore
     */
    samplingProtocol?: string;
    /**
     * pode ser bioma, ecorregião que caracterize o ambiente natural do espécime
     * @type {string}
     * @memberof ZUFMSCore
     */
    habitat?: string;
    /**
     * comentários sobre o evento
     * @type {string}
     * @memberof ZUFMSCore
     */
    eventRemarks?: string;
    /**
     * pode ser um indicador da existencia de, b) uma referência a (publicação, link), ou c) texto das notas tomadas no campo sobre o evento
     * @type {string}
     * @memberof ZUFMSCore
     */
    fieldNotes?: string;
    /**
     * comentários ou notas que acompanham medições ou fatos; medidas concatenadas com ";" informando unidade
     * @type {string}
     * @memberof ZUFMSCore
     */
    measurementRemarks?: string;
    /**
     * apenas se for um divisão válida
     * @type {string}
     * @memberof ZUFMSCore
     */
    continent?: string;
    /**
     * nome do país
     * @type {string}
     * @memberof ZUFMSCore
     */
    country?: string;
    /**
     * codificação de acordo com ISO3166-1 e código alfa-3
     * @type {string}
     * @memberof ZUFMSCore
     */
    countryCode?: string;
    /**
     * utilizar quando se trata de organismos aquáticos
     * @type {string}
     * @memberof ZUFMSCore
     */
    verbatimLocality?: string;
    /**
     * escrito por extenso, utilizar região quando são áreas de divisa entre estados
     * @type {string}
     * @memberof ZUFMSCore
     */
    stateProvince?: string;
    /**
     * o nome do município válido
     * @type {string}
     * @memberof ZUFMSCore
     */
    county?: string;
    /**
     * quando há necessidade de informar distrito ou sub-região (ex.: Pantanal da Nhecolândia)
     * @type {string}
     * @memberof ZUFMSCore
     */
    municipality?: string;
    /**
     * a localidade abaixo de município ou distrito
     * @type {string}
     * @memberof ZUFMSCore
     */
    locality?: string;
    /**
     * coordenada em formato decimal, a célula deve estar formatada em texto
     * @type {number}
     * @memberof ZUFMSCore
     */
    decimalLatitude?: number;
    /**
     * coordenada em formato decimal, a célula deve estar formatada em texto
     * @type {number}
     * @memberof ZUFMSCore
     */
    decimalLongitude?: number;
    /**
     * informar se não houver decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    verbatimLatitude?: string;
    /**
     * informar se não houver decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    verbatimLongitude?: string;
    /**
     * precisão em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    coordinatePrecision?: number;
    /**
     * informar somente se decimal
     * @type {string}
     * @memberof ZUFMSCore
     */
    geodeticDatum?: string;
    /**
     * quando não se sabe a coordenada exata; acesse http://boundingbox.klokantech.com/ para estimar o quadrante
     * @type {string}
     * @memberof ZUFMSCore
     */
    footprintWKT?: string;
    /**
     * limite inferior do intervalo da elevação
     * @type {number}
     * @memberof ZUFMSCore
     */
    minimumElevationInMeters?: number;
    /**
     * limite superior do intervalo da elevação
     * @type {number}
     * @memberof ZUFMSCore
     */
    maximumElevationInMeters?: number;
    /**
     * o nome do corpo d'água lótico/lêntico onde foi coletado; mais detalhes acesse http://www.getty.edu/research/tools/vocabularies/tgn/
     * @type {string}
     * @memberof ZUFMSCore
     */
    waterBody?: string;
    /**
     * a menor profundidade de um intervalo de profundidades abaixo da superfície do local, em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    minimumDepthInMeters?: number;
    /**
     * a maior profundidade de um intervalo de profundidades abaixo da superfície do local, em metros
     * @type {number}
     * @memberof ZUFMSCore
     */
    maximumDepthInMeters?: number;
    /**
     * comentários sobre o local onde foi coletado
     * @type {string}
     * @memberof ZUFMSCore
     */
    locationRemarks?: string;
    /**
     * quando não se sabe ao certo a identificação 
     * @type {string}
     * @memberof ZUFMSCore
     */
    identificationQualifier?: string;
    /**
     * o sobrenome e nome abreviado em caixa alta segundo o exemplo de quem identificou o material
     * @type {string}
     * @memberof ZUFMSCore
     */
    identifiedBy?: string;
    /**
     * data da determsinação no formato aaaa-mm-dd
     * @type {Date}
     * @memberof ZUFMSCore
     */
    dateIdentified?: Date;
    /**
     * informa se é tipo nomenclatural ou apenas voucher, se necessário concatenar com ";"
     * @type {string}
     * @memberof ZUFMSCore
     */
    typeStatus?: string;
    /**
     * similar ao Nome Científico Aceito, mas aqui utilizamos sem autoria
     * @type {string}
     * @memberof ZUFMSCore
     */
    scientificName?: string;
    /**
     * autor e ano, segundo o código de nomenclatura seguido
     * @type {string}
     * @memberof ZUFMSCore
     */
    scientificNameAuthorship?: string;
    /**
     * identificação do táxon com autor até onde foi possível, não importando a categoria taxonômica
     * @type {string}
     * @memberof ZUFMSCore
     */
    acceptedNameUsage?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    subgenus?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    genus?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsubtribe?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialtribe?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsubfamily?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    family?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsuperfamily?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialinfraorder?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsuborder?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    order?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsuperorder?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsubclass?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    _class?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    artificialsubphylum?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    phylum?: string;
    /**
     * campo obrigatório
     * @type {string}
     * @memberof ZUFMSCore
     */
    kingdom?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    specificEpithet?: string;
    /**
     * se identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    infraspecificEpithet?: string;
    /**
     * informa até que nível taxonômico foi identificado
     * @type {string}
     * @memberof ZUFMSCore
     */
    taxonRank?: string;
    /**
     * informa a condição taxonômica:
     * @type {string}
     * @memberof ZUFMSCore
     */
    taxonomicStatus?: string;
    /**
     * se for um táxon com problemas, informar o original
     * @type {string}
     * @memberof ZUFMSCore
     */
    originalNameUsage?: string;
    /**
     * nome popular hifenizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    vernacularName?: string;
    /**
     * informa qual código ou sistema de classificação está sendo utilizado para o registro
     * @type {string}
     * @memberof ZUFMSCore
     */
    nomenclaturalCode?: string;
    /**
     * o sistema de classificação no qual este grupo está organizado
     * @type {string}
     * @memberof ZUFMSCore
     */
    nameAccordingTo?: string;
    /**
     * informar a relação com o Item Relacionado ao Catálogo
     * @type {string}
     * @memberof ZUFMSCore
     */
    relationshipOfResource?: string;
}

export function ZUFMSCoreFromJSON(json: any): ZUFMSCore {
    return ZUFMSCoreFromJSONTyped(json, false);
}

export function ZUFMSCoreFromJSONTyped(json: any, ignoreDiscriminator: boolean): ZUFMSCore {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'artificialsection': !exists(json, 'artificial:section') ? undefined : json['artificial:section'],
        'dctermsmodified': !exists(json, 'dcterms:modified') ? undefined : (new Date(json['dcterms:modified'])),
        'informationWithheld': !exists(json, 'informationWithheld') ? undefined : json['informationWithheld'],
        'basisOfRecord': !exists(json, 'basisOfRecord') ? undefined : json['basisOfRecord'],
        'institutionCode': !exists(json, 'institutionCode') ? undefined : json['institutionCode'],
        'collectionCode': !exists(json, 'collectionCode') ? undefined : json['collectionCode'],
        'dctermsbibliographicCitation': !exists(json, 'dcterms:bibliographicCitation') ? undefined : json['dcterms:bibliographicCitation'],
        'datasetName': !exists(json, 'datasetName') ? undefined : json['datasetName'],
        'artificialshelfLocation': !exists(json, 'artificial:shelfLocation') ? undefined : json['artificial:shelfLocation'],
        'artificialflaskLocation': !exists(json, 'artificial:flaskLocation') ? undefined : json['artificial:flaskLocation'],
        'artificialshippingGuide': !exists(json, 'artificial:shippingGuide') ? undefined : json['artificial:shippingGuide'],
        'catalogNumber': !exists(json, 'catalogNumber') ? undefined : json['catalogNumber'],
        'otherCatalogNumbers': !exists(json, 'otherCatalogNumbers') ? undefined : json['otherCatalogNumbers'],
        'recordedBy': !exists(json, 'recordedBy') ? undefined : json['recordedBy'],
        'recordNumber': !exists(json, 'recordNumber') ? undefined : json['recordNumber'],
        'preparations': !exists(json, 'preparations') ? undefined : json['preparations'],
        'individualCount': !exists(json, 'individualCount') ? undefined : json['individualCount'],
        'sex': !exists(json, 'sex') ? undefined : json['sex'],
        'lifeStage': !exists(json, 'lifeStage') ? undefined : json['lifeStage'],
        'reproductiveCondition': !exists(json, 'reproductiveCondition') ? undefined : json['reproductiveCondition'],
        'establishmentMeans': !exists(json, 'establishmentMeans') ? undefined : json['establishmentMeans'],
        'behavior': !exists(json, 'behavior') ? undefined : json['behavior'],
        'occurrenceRemarks': !exists(json, 'occurrenceRemarks') ? undefined : json['occurrenceRemarks'],
        'disposition': !exists(json, 'disposition') ? undefined : json['disposition'],
        'associatedReferences': !exists(json, 'associatedReferences') ? undefined : json['associatedReferences'],
        'associatedMedia': !exists(json, 'associatedMedia') ? undefined : json['associatedMedia'],
        'occurrenceID': !exists(json, 'occurrenceID') ? undefined : json['occurrenceID'],
        'associatedOccurrences': !exists(json, 'associatedOccurrences') ? undefined : json['associatedOccurrences'],
        'previousIdentifications': !exists(json, 'previousIdentifications') ? undefined : json['previousIdentifications'],
        'fieldNumber': !exists(json, 'fieldNumber') ? undefined : json['fieldNumber'],
        'day': !exists(json, 'day') ? undefined : json['day'],
        'month': !exists(json, 'month') ? undefined : json['month'],
        'year': !exists(json, 'year') ? undefined : json['year'],
        'eventTime': !exists(json, 'eventTime') ? undefined : json['eventTime'],
        'eventDate': !exists(json, 'eventDate') ? undefined : json['eventDate'],
        'verbatimEventDate': !exists(json, 'verbatimEventDate') ? undefined : json['verbatimEventDate'],
        'samplingProtocol': !exists(json, 'samplingProtocol') ? undefined : json['samplingProtocol'],
        'habitat': !exists(json, 'habitat') ? undefined : json['habitat'],
        'eventRemarks': !exists(json, 'eventRemarks') ? undefined : json['eventRemarks'],
        'fieldNotes': !exists(json, 'fieldNotes') ? undefined : json['fieldNotes'],
        'measurementRemarks': !exists(json, 'measurementRemarks') ? undefined : json['measurementRemarks'],
        'continent': !exists(json, 'continent') ? undefined : json['continent'],
        'country': !exists(json, 'country') ? undefined : json['country'],
        'countryCode': !exists(json, 'countryCode') ? undefined : json['countryCode'],
        'verbatimLocality': !exists(json, 'verbatimLocality') ? undefined : json['verbatimLocality'],
        'stateProvince': !exists(json, 'stateProvince') ? undefined : json['stateProvince'],
        'county': !exists(json, 'county') ? undefined : json['county'],
        'municipality': !exists(json, 'municipality') ? undefined : json['municipality'],
        'locality': !exists(json, 'locality') ? undefined : json['locality'],
        'decimalLatitude': !exists(json, 'decimalLatitude') ? undefined : json['decimalLatitude'],
        'decimalLongitude': !exists(json, 'decimalLongitude') ? undefined : json['decimalLongitude'],
        'verbatimLatitude': !exists(json, 'verbatimLatitude') ? undefined : json['verbatimLatitude'],
        'verbatimLongitude': !exists(json, 'verbatimLongitude') ? undefined : json['verbatimLongitude'],
        'coordinatePrecision': !exists(json, 'coordinatePrecision') ? undefined : json['coordinatePrecision'],
        'geodeticDatum': !exists(json, 'geodeticDatum') ? undefined : json['geodeticDatum'],
        'footprintWKT': !exists(json, 'footprintWKT') ? undefined : json['footprintWKT'],
        'minimumElevationInMeters': !exists(json, 'minimumElevationInMeters') ? undefined : json['minimumElevationInMeters'],
        'maximumElevationInMeters': !exists(json, 'maximumElevationInMeters') ? undefined : json['maximumElevationInMeters'],
        'waterBody': !exists(json, 'waterBody') ? undefined : json['waterBody'],
        'minimumDepthInMeters': !exists(json, 'minimumDepthInMeters') ? undefined : json['minimumDepthInMeters'],
        'maximumDepthInMeters': !exists(json, 'maximumDepthInMeters') ? undefined : json['maximumDepthInMeters'],
        'locationRemarks': !exists(json, 'locationRemarks') ? undefined : json['locationRemarks'],
        'identificationQualifier': !exists(json, 'identificationQualifier') ? undefined : json['identificationQualifier'],
        'identifiedBy': !exists(json, 'identifiedBy') ? undefined : json['identifiedBy'],
        'dateIdentified': !exists(json, 'dateIdentified') ? undefined : (new Date(json['dateIdentified'])),
        'typeStatus': !exists(json, 'typeStatus') ? undefined : json['typeStatus'],
        'scientificName': !exists(json, 'scientificName') ? undefined : json['scientificName'],
        'scientificNameAuthorship': !exists(json, 'scientificNameAuthorship') ? undefined : json['scientificNameAuthorship'],
        'acceptedNameUsage': !exists(json, 'acceptedNameUsage') ? undefined : json['acceptedNameUsage'],
        'subgenus': !exists(json, 'subgenus') ? undefined : json['subgenus'],
        'genus': !exists(json, 'genus') ? undefined : json['genus'],
        'artificialsubtribe': !exists(json, 'artificial:subtribe') ? undefined : json['artificial:subtribe'],
        'artificialtribe': !exists(json, 'artificial:tribe') ? undefined : json['artificial:tribe'],
        'artificialsubfamily': !exists(json, 'artificial:subfamily') ? undefined : json['artificial:subfamily'],
        'family': !exists(json, 'family') ? undefined : json['family'],
        'artificialsuperfamily': !exists(json, 'artificial:superfamily') ? undefined : json['artificial:superfamily'],
        'artificialinfraorder': !exists(json, 'artificial:infraorder') ? undefined : json['artificial:infraorder'],
        'artificialsuborder': !exists(json, 'artificial:suborder') ? undefined : json['artificial:suborder'],
        'order': !exists(json, 'order') ? undefined : json['order'],
        'artificialsuperorder': !exists(json, 'artificial:superorder') ? undefined : json['artificial:superorder'],
        'artificialsubclass': !exists(json, 'artificial:subclass') ? undefined : json['artificial:subclass'],
        '_class': !exists(json, 'class') ? undefined : json['class'],
        'artificialsubphylum': !exists(json, 'artificial:subphylum') ? undefined : json['artificial:subphylum'],
        'phylum': !exists(json, 'phylum') ? undefined : json['phylum'],
        'kingdom': !exists(json, 'kingdom') ? undefined : json['kingdom'],
        'specificEpithet': !exists(json, 'specificEpithet') ? undefined : json['specificEpithet'],
        'infraspecificEpithet': !exists(json, 'infraspecificEpithet') ? undefined : json['infraspecificEpithet'],
        'taxonRank': !exists(json, 'taxonRank') ? undefined : json['taxonRank'],
        'taxonomicStatus': !exists(json, 'taxonomicStatus') ? undefined : json['taxonomicStatus'],
        'originalNameUsage': !exists(json, 'originalNameUsage') ? undefined : json['originalNameUsage'],
        'vernacularName': !exists(json, 'vernacularName') ? undefined : json['vernacularName'],
        'nomenclaturalCode': !exists(json, 'nomenclaturalCode') ? undefined : json['nomenclaturalCode'],
        'nameAccordingTo': !exists(json, 'nameAccordingTo') ? undefined : json['nameAccordingTo'],
        'relationshipOfResource': !exists(json, 'relationshipOfResource') ? undefined : json['relationshipOfResource'],
    };
}

export function ZUFMSCoreToJSON(value?: ZUFMSCore | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'artificial:section': value.artificialsection,
        'dcterms:modified': value.dctermsmodified === undefined ? undefined : (value.dctermsmodified.toISOString().substr(0,10)),
        'informationWithheld': value.informationWithheld,
        'basisOfRecord': value.basisOfRecord,
        'institutionCode': value.institutionCode,
        'collectionCode': value.collectionCode,
        'dcterms:bibliographicCitation': value.dctermsbibliographicCitation,
        'datasetName': value.datasetName,
        'artificial:shelfLocation': value.artificialshelfLocation,
        'artificial:flaskLocation': value.artificialflaskLocation,
        'artificial:shippingGuide': value.artificialshippingGuide,
        'catalogNumber': value.catalogNumber,
        'otherCatalogNumbers': value.otherCatalogNumbers,
        'recordedBy': value.recordedBy,
        'recordNumber': value.recordNumber,
        'preparations': value.preparations,
        'individualCount': value.individualCount,
        'sex': value.sex,
        'lifeStage': value.lifeStage,
        'reproductiveCondition': value.reproductiveCondition,
        'establishmentMeans': value.establishmentMeans,
        'behavior': value.behavior,
        'occurrenceRemarks': value.occurrenceRemarks,
        'disposition': value.disposition,
        'associatedReferences': value.associatedReferences,
        'associatedMedia': value.associatedMedia,
        'occurrenceID': value.occurrenceID,
        'associatedOccurrences': value.associatedOccurrences,
        'previousIdentifications': value.previousIdentifications,
        'fieldNumber': value.fieldNumber,
        'day': value.day,
        'month': value.month,
        'year': value.year,
        'eventTime': value.eventTime,
        'eventDate': value.eventDate,
        'verbatimEventDate': value.verbatimEventDate,
        'samplingProtocol': value.samplingProtocol,
        'habitat': value.habitat,
        'eventRemarks': value.eventRemarks,
        'fieldNotes': value.fieldNotes,
        'measurementRemarks': value.measurementRemarks,
        'continent': value.continent,
        'country': value.country,
        'countryCode': value.countryCode,
        'verbatimLocality': value.verbatimLocality,
        'stateProvince': value.stateProvince,
        'county': value.county,
        'municipality': value.municipality,
        'locality': value.locality,
        'decimalLatitude': value.decimalLatitude,
        'decimalLongitude': value.decimalLongitude,
        'verbatimLatitude': value.verbatimLatitude,
        'verbatimLongitude': value.verbatimLongitude,
        'coordinatePrecision': value.coordinatePrecision,
        'geodeticDatum': value.geodeticDatum,
        'footprintWKT': value.footprintWKT,
        'minimumElevationInMeters': value.minimumElevationInMeters,
        'maximumElevationInMeters': value.maximumElevationInMeters,
        'waterBody': value.waterBody,
        'minimumDepthInMeters': value.minimumDepthInMeters,
        'maximumDepthInMeters': value.maximumDepthInMeters,
        'locationRemarks': value.locationRemarks,
        'identificationQualifier': value.identificationQualifier,
        'identifiedBy': value.identifiedBy,
        'dateIdentified': value.dateIdentified === undefined ? undefined : (value.dateIdentified.toISOString().substr(0,10)),
        'typeStatus': value.typeStatus,
        'scientificName': value.scientificName,
        'scientificNameAuthorship': value.scientificNameAuthorship,
        'acceptedNameUsage': value.acceptedNameUsage,
        'subgenus': value.subgenus,
        'genus': value.genus,
        'artificial:subtribe': value.artificialsubtribe,
        'artificial:tribe': value.artificialtribe,
        'artificial:subfamily': value.artificialsubfamily,
        'family': value.family,
        'artificial:superfamily': value.artificialsuperfamily,
        'artificial:infraorder': value.artificialinfraorder,
        'artificial:suborder': value.artificialsuborder,
        'order': value.order,
        'artificial:superorder': value.artificialsuperorder,
        'artificial:subclass': value.artificialsubclass,
        'class': value._class,
        'artificial:subphylum': value.artificialsubphylum,
        'phylum': value.phylum,
        'kingdom': value.kingdom,
        'specificEpithet': value.specificEpithet,
        'infraspecificEpithet': value.infraspecificEpithet,
        'taxonRank': value.taxonRank,
        'taxonomicStatus': value.taxonomicStatus,
        'originalNameUsage': value.originalNameUsage,
        'vernacularName': value.vernacularName,
        'nomenclaturalCode': value.nomenclaturalCode,
        'nameAccordingTo': value.nameAccordingTo,
        'relationshipOfResource': value.relationshipOfResource,
    };
}

